package com.talytica.survey.resources;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import javax.ws.rs.Consumes;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.employmeo.data.model.Respondant;
import com.employmeo.data.model.Response;
import com.employmeo.data.model.Survey;
import com.employmeo.data.model.SurveyQuestion;
import com.employmeo.data.model.SurveySection;
import com.employmeo.data.service.AccountSurveyService;
import com.employmeo.data.service.RespondantService;
import com.twilio.sdk.verbs.Record;
import com.twilio.sdk.verbs.Redirect;
import com.twilio.sdk.verbs.Say;
import com.twilio.sdk.verbs.TwiMLException;
import com.twilio.sdk.verbs.TwiMLResponse;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiParam;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
@Produces(MediaType.APPLICATION_XML)
@Path("/1/twilio")
@Api( value="/1/twilio", produces=MediaType.APPLICATION_XML, consumes=MediaType.APPLICATION_FORM_URLENCODED)
public class TwilioResource {
	
	@Value("${}")
	public String BASE_SURVEY_URL;
	
	@Autowired
	RespondantService respondantService;
	
	@Autowired
	AccountSurveyService accountSurveyService;
	
	/*******************
	 * For all voice data Collection using the Twilio API, the following
	 * parameters come with the API call from Twilio:
	 * allSid	A unique identifier for this call, generated by Twilio.
	 * @param AccountSid	Your Twilio account id. It is 34 characters long,
	 * 						and always starts with the letters AC.
	 * @param From			The phone number, URI or client identifier
	 * @param To			The phone number, URI or client identifier
	 * @param CallStatus	A descriptive status for the call. The value is
	 * 						one of queued, ringing, in-progress, completed, 
	 * 						busy, failed or no-answer.
	 * @param ApiVersion	The version of the Twilio API.
	 * @param Direction		A string describing the direction of the call.
	 * @param ForwardedFrom	This parameter is set only when Twilio receives 
	 * 						a forwarded call, but depends on the carrier
	 * @param CallerName	VoiceCallerIdLookup value ($0.01 per look up).
	 * @return TwiML 		Response
	 */
	
	
	@POST
	@Path("/capture/{respondantId}/{questionId}")
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	@Produces(MediaType.APPLICATION_XML)
	public String captureRecording(
			@ApiParam(value = "Respondant ID") @PathParam("respondantId") Long respondantId,
			@ApiParam(value = "Question ID") @PathParam("questionId") Long questionId,
			@ApiParam(value = "From") @FormParam("From") String twiFrom,
			@ApiParam(value = "RecordingUrl") @FormParam("RecordingUrl") String recUrl,
			@ApiParam(value = "RecordingDuration") @FormParam("RecordingDuration") Integer recDuration) {
		
		log.debug("Twilio Capture Recording called by {} with {} for respondant {} and question {}", 
				twiFrom, recUrl, respondantId, questionId);
		
		Respondant respondant = respondantService.getRespondantById(respondantId);
		if ((questionId != null) && (recUrl != null)) {
			// Save the response
			Response recording = new Response();
			recording.setRespondant(respondant);
			recording.setResponseText(recUrl);
			recording.setResponseValue(recDuration);
			recording.setQuestionId(questionId);
			Response savedRecording = respondantService.saveResponse(recording);
			respondant.getResponses().add(savedRecording);
		}

		log.debug("Twilio Capture Recording called by {} with {} for respondant {} and question {}", 
				twiFrom, recUrl, respondantId, questionId);
		// present the next question		
		TwiMLResponse twiML = new TwiMLResponse();
		try {
			nextQuestionTwiML(twiML, respondant);
		} catch (TwiMLException e) {
			e.printStackTrace();
		}
		return twiML.toEscapedXML();
		
	}

	@GET
	@Path("/nextquestion/{respondantId}")
	@Produces(MediaType.APPLICATION_XML)
	public String nextQuestion(@ApiParam(value = "Respondant ID") @PathParam("respondantId") Long respondantId) {
		
		Respondant respondant = respondantService.getRespondantById(respondantId);
		TwiMLResponse twiML = new TwiMLResponse();
		try {
			nextQuestionTwiML(twiML, respondant);
		} catch (TwiMLException e) {
			e.printStackTrace();
		}
		return twiML.toEscapedXML();
		
	}

	@GET
	@Path("/findsurvey/{asId}")
	@Produces(MediaType.APPLICATION_XML)
	public String findSurvey(
			@ApiParam(value = "Account Survey ID") @PathParam("asId") Long asId,
			@ApiParam(value = "From") @QueryParam("From") String twiFrom,
			@ApiParam(value = "Digits") @QueryParam("Digits") String twiDigits) {	
		Respondant resp = respondantService.getRespondantByAccountSurveyIdAndPayrollId(asId, twiDigits);

	    TwiMLResponse twiML = new TwiMLResponse();
	    try {

	    	if (resp != null) {
	        	Survey survey = resp.getAccountSurvey().getSurvey();
	        	// TODO hard coded to assume we have only one section... maybe need to fix!
	        	SurveySection section = new ArrayList<SurveySection>(survey.getSurveySections()).get(0);
	        	
	    		Say thanks = new Say("Thank you. You are " + resp.getPerson().getFirstName() + " " + resp.getPerson().getLastName() + " ." );
	        	Say instructions = new Say(section.getInstructions());
		    	twiML.append(thanks);
		    	twiML.append(instructions);
	        	nextQuestionTwiML(twiML, resp);
	 
	    	} else {
	    		Say sorry = new Say("Sorry. We are unable to match your ID. Goodbye!");
	    		twiML.append(sorry);
	    	}
	    } catch (TwiMLException e) {
	        e.printStackTrace();
	    }
	    
	    return twiML.toEscapedXML();	
		
	}

	
	private void nextQuestionTwiML(TwiMLResponse twiML, Respondant resp) throws TwiMLException {
	    // get Survey Questions & sort
	    SurveyQuestion nextQuestion = nextQuestion(resp);
        if (nextQuestion != null) {  
	        Say prompt = new Say("Question " + nextQuestion.getSequence() + ". " +
	        		nextQuestion.getQuestion().getQuestionText());
	        Record record = new Record();
	        record.setMethod("POST");
	        record.setAction(BASE_SURVEY_URL + "/1/twilio/capture/" + 
	            resp.getId() + "/"  + nextQuestion.getQuestion().getQuestionId());
	        record.setMaxLength(90);
	
	        Say tryagain = new Say("Sorry - we did not recieve a response. Please try again.");
	        Redirect redirect = new Redirect(BASE_SURVEY_URL + "/1/twilio/nextquestion/" + resp.getId());
	        redirect.setMethod("GET");


	    	    twiML.append(prompt);
	    	    twiML.append(record);
	    	    twiML.append(tryagain);
	    	    twiML.append(redirect);

        } else {
	        Say goodbye = new Say("Thank You. You have completed the questionairre. Goodbye.");
    	    twiML.append(goodbye);

        }
	}
	
	
	private SurveyQuestion nextQuestion(Respondant resp) {
		SurveyQuestion nextQuestion = null;
		List<SurveyQuestion> questions = new ArrayList<SurveyQuestion>(resp.getAccountSurvey().getSurvey().getSurveyQuestions());
		questions.sort(new Comparator<SurveyQuestion>() {
			public int compare(SurveyQuestion sq1, SurveyQuestion sq2) {
		    	int result = sq1.getPage() - sq2.getPage();
		    	if (result == 0) result = sq1.getSequence() - sq2.getSequence();
		    	return result;
			}
		});
		
		// get responses
		List<Response> responses = new ArrayList<Response>(resp.getResponses());

		for (SurveyQuestion question : questions) {
			boolean isAnswered = false;
			for (Response answer : responses) {
				if (question.getQuestion().getQuestionId().equals(answer.getQuestionId())) {
					isAnswered = true;
					break;
				}
			}
			if (!isAnswered) {
				nextQuestion = question;
				break;
			}
		}
		return nextQuestion;	    
	}
		
}